package com.danielpark.camera;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.ImageFormat;
import android.graphics.Matrix;
import android.graphics.Point;
import android.graphics.RectF;
import android.graphics.SurfaceTexture;
import android.hardware.SensorManager;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.media.Image;
import android.media.ImageReader;
import android.os.Build;
import android.os.Environment;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.support.annotation.NonNull;
import android.util.Log;
import android.util.Size;
import android.util.SparseIntArray;
import android.view.OrientationEventListener;
import android.view.Surface;
import android.view.TextureView;
import android.view.WindowManager;

import com.danielpark.camera.listeners.OnTakePictureListener;
import com.danielpark.camera.util.AutoFitTextureView;
import com.danielpark.camera.util.DeviceUtil;
import com.danielpark.camera.util.Logger;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

import static com.danielpark.camera.Camera2Preview.CameraState.STATE_LOCKED;
import static com.danielpark.camera.Camera2Preview.CameraState.STATE_PREVIEW;
import static com.danielpark.camera.Camera2Preview.CameraState.STATE_WAITING_LOCK;

/**
 * Camera2 API preview
 * <br><br>
 * Copyright (C) 2014-2016 daniel@bapul.net
 * Created by Daniel on 2016-08-26.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public class Camera2Preview extends AutoFitTextureView {

    private CameraDevice mCameraDevice;
    private CameraManager mCameraManager;
    private String mCameraId; // ID of the current CameraDevice
    private Size mPreviewSize;  // Size of camera preview
    private int mSensorOrientation;

    /** A {@link CameraCaptureSession } for camera preview */
    private CameraCaptureSession mCameraCaptureSession;

    private Size[] mSupportedPreviewSize;
    /** Camera back lens' feature */
    private CameraCharacteristics mCameraCharacteristics;

    /** A {@link Handler} for running tasks in the background */
    private Handler mBackgroundHandler;
    /** An additional thread for running tasks that shouldn't block the UI */
    private HandlerThread mBackgroundThread;
    /** {@link CaptureRequest.Builder} for the camera preview */
    private CaptureRequest.Builder mPreviewRequestBuilder;
    /** {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder} */
    private CaptureRequest mPreviewRequest;
    /** An {@link ImageReader} that handles still image capture */
    private ImageReader mImageReader;
    /** An output file for our picture */
    private File mTakePictureFile = getOutputMediaFile();
    /** A {@link Semaphore} to prevent the app from exiting before closing the camera. */
    private Semaphore mCameraOpenCloseLock = new Semaphore(1);
    /** Current camera state */
    private CameraState mState = STATE_PREVIEW;

    enum CameraState {
        STATE_PREVIEW,          // Showing camera preview
        STATE_WAITING_LOCK,     // Waiting for the focus to be locked
        STATE_LOCKED,           // The focus is locked
        STATE_PICTURE_TAKEN,    // Picture was taken
    }

    /** A {@link Handler} key when it succeeds to focus lens */
    private final static int DELIVER_LENS_FOCUS_SUCCEED = 4423;
    /** A {@link Handler} key when it fails focusing lens */
    private final static int DELIVER_LENS_FOCUS_FAILED = 4424;
    /** A {@link Handler} key when finished creating photo */
    private final static int DELIVER_FINISHED_TAKING_PICTURE = 4425;

    /** Orientation event flag */
    private boolean isOrientationEventAvailable = false;
    /** Last changed orientation */
    private int mLastOrientation;
    private Integer mLastConvertedOrientation;
    private OnTakePictureListener onTakePictureListener;
    private OrientationEventListener mOrientationEventListener;

    private static final SparseIntArray ORIENTATIONS = new SparseIntArray();

    static {
        ORIENTATIONS.append(Surface.ROTATION_0, 0);
        ORIENTATIONS.append(Surface.ROTATION_90, 90);
        ORIENTATIONS.append(Surface.ROTATION_180, 180);
        ORIENTATIONS.append(Surface.ROTATION_270, 270);
    }

    public Camera2Preview(Context context) {
        super(context);

        setSurfaceTextureListener(mSurfaceTextureListener);
    }

    private final TextureView.SurfaceTextureListener mSurfaceTextureListener
            = new TextureView.SurfaceTextureListener() {

        @Override
        public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int width, int height) {
            try {
                openCamera(surfaceTexture, width, height);
            } catch (CameraAccessException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onSurfaceTextureSizeChanged(SurfaceTexture surfaceTexture, int width, int height) {
            configureTransform(surfaceTexture, width, height);
        }

        @Override
        public boolean onSurfaceTextureDestroyed(SurfaceTexture surfaceTexture) {
            releaseCamera();
            return true;
        }

        @Override
        public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {

        }
    };

    /**
     * {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state.
     */
    private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {

        @Override
        public void onOpened(CameraDevice camera) {
            // This method is called when the camera is opened. We start camera preview here
            mCameraOpenCloseLock.release();
            mCameraDevice = camera;
            // TODO: startPreview
            try {
                startPreview();
            } catch (CameraAccessException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
            mCameraOpenCloseLock.release();
            camera.close();
            mCameraDevice = null;
        }

        @Override
        public void onError(CameraDevice camera, int error) {
            mCameraOpenCloseLock.release();
            camera.close();
            mCameraDevice = null;
        }
    };

    /**
     * To tell if {@link ImageSaver} finished storing Image byte[] to file
     */
    Handler mOnImageFinishedHandler = new Handler(){

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);

            if (msg != null)
                LOG.d("handleMessage : " + msg.toString());

            switch (msg.what) {
                case DELIVER_LENS_FOCUS_SUCCEED: {
                    if (onTakePictureListener != null)
                        onTakePictureListener.onLensFocused(true);
                    break;
                }
                case DELIVER_LENS_FOCUS_FAILED: {
                    if (onTakePictureListener != null)
                        onTakePictureListener.onLensFocused(false);
                    break;
                }
                case DELIVER_FINISHED_TAKING_PICTURE: {
                    if (onTakePictureListener != null && mTakePictureFile != null)
                        onTakePictureListener.onTakePicture(mTakePictureFile);
                    break;
                }
            }
        }
    };

    /**
     * This a callback object for the {@link ImageReader}. "onImageAvailable" will be called when a
     * still image is ready to be saved.
     */
    private final ImageReader.OnImageAvailableListener mOnImageAvailableListener
            = new ImageReader.OnImageAvailableListener() {

        @Override
        public void onImageAvailable(ImageReader reader) {
            mBackgroundHandler.post(new ImageSaver(reader.acquireNextImage(), mTakePictureFile
                    , mConfigureTransformMargin, mLastConvertedOrientation, mOnImageFinishedHandler));
        }
    };

    /**
     * A {@link CameraCaptureSession.CaptureCallback} that handles events related to JPEG capture.
     */
    private CameraCaptureSession.CaptureCallback mCaptureCallback
            = new CameraCaptureSession.CaptureCallback() {


        @Override
        public void onCaptureCompleted(@NonNull CameraCaptureSession session,
                                       @NonNull CaptureRequest request,
                                       @NonNull TotalCaptureResult result) {

            switch (mState) {
                case STATE_PREVIEW: {
                    break;
                }
                case STATE_WAITING_LOCK: {
                    Integer afState = result.get(CaptureResult.CONTROL_AF_STATE);
                    if (afState == null) {
                        LOG.d("onCaptureCompleted : " + mState.name());
                        mState = STATE_PREVIEW;

                        // No information
                        if (mOnImageFinishedHandler != null) {
                            mOnImageFinishedHandler.sendEmptyMessageDelayed(DELIVER_LENS_FOCUS_FAILED, 100);
                        }
                    }
                    else if (afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED) {
                        LOG.d("onCaptureCompleted : " + mState.name());
                        mState = STATE_LOCKED;

                        // Focused locked
                        if (mOnImageFinishedHandler != null) {
                            mOnImageFinishedHandler.sendEmptyMessageDelayed(DELIVER_LENS_FOCUS_SUCCEED, 100);
                        }
                    }
                    else if (afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED) {
                        LOG.d("onCaptureCompleted : " + mState.name());
                        mState = STATE_LOCKED;

                        // Not focused
                        if (mOnImageFinishedHandler != null) {
                            mOnImageFinishedHandler.sendEmptyMessageDelayed(DELIVER_LENS_FOCUS_FAILED, 100);
                        }
                    }
                    break;
                }
                case STATE_LOCKED: {

                    break;
                }
            }
        }
    };

    @Override
    public void openCamera(SurfaceTexture surfaceTexture, int width, int height) throws CameraAccessException, SecurityException {
//        super.openCamera(surfaceTexture, width, height);
        LOG.d("openCamera() : " + width + " , " + height);

        /**
         * If OrientationEventListener is available then open it
         */
        if (mOrientationEventListener != null && mOrientationEventListener.canDetectOrientation())
            mOrientationEventListener.enable();

        // Daniel (2016-10-25 23:32:40): Start handler thread
        startBackgroundThread();

        if (mCameraManager == null)
            mCameraManager = (CameraManager) getContext().getSystemService(Context.CAMERA_SERVICE);

        setUpCameraOutput(width, height, mCameraManager);
        configureTransform(surfaceTexture, width, height);

        try {
            if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw new RuntimeException("Time out waiting to lock camera opening.");
            }
            mCameraManager.openCamera(mCameraId, mStateCallback, mBackgroundHandler);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * Check if current device gets correct orientation compares to preview size
     * @return
     */
    private boolean isCorrectOrientation() {
        // Daniel (2016-08-26 12:17:06): Get the largest supported preview size
        Size largestPreviewSize = Collections.max(
                Arrays.asList(mSupportedPreviewSize),
                new CompareSizesByArea());

        // Daniel (2016-08-26 12:17:33): Get current device configuration
        int orientation = getResources().getConfiguration().orientation;

        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
            int screenWidth = DeviceUtil.getResolutionWidth(getContext());
            int screenHeight = DeviceUtil.getResolutionHeight(getContext());

            if ((screenWidth > screenHeight && largestPreviewSize.getWidth() < largestPreviewSize.getHeight())
                    || (screenWidth < screenHeight && largestPreviewSize.getWidth() > largestPreviewSize.getHeight()))
                return false;
            else
                return true;


        } else if (orientation == Configuration.ORIENTATION_PORTRAIT) {
            int screenWidth = DeviceUtil.getResolutionWidth(getContext());
            int screenHeight = DeviceUtil.getResolutionHeight(getContext());

            if ((screenWidth > screenHeight && largestPreviewSize.getWidth() < largestPreviewSize.getHeight())
                    || (screenWidth < screenHeight && largestPreviewSize.getWidth() > largestPreviewSize.getHeight()))
                return false;
            else
                return true;
        }
        return true;
    }

    /**
     * Sets up member variables related to camera.
     *
     * @param width  The width of available size for camera preview
     * @param height The height of available size for camera preview
     */
    private void setUpCameraOutput(int width, int height, CameraManager cameraManager) throws CameraAccessException, NullPointerException {
        LOG.d("setupCameraOutput() : " + width + " , " + height);

        // TODO: For now, only rear Camera is supported
        for (String cameraId : cameraManager.getCameraIdList()) {
            CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId);

            // We don't use a front camera for now
            Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);
            if (facing != null && facing == CameraCharacteristics.LENS_FACING_FRONT)
                continue;

            // We don't use an external camera in this class
            if (facing != null && facing == CameraCharacteristics.LENS_FACING_EXTERNAL)
                continue;

            StreamConfigurationMap map = characteristics.get(
                    CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            if (map == null) {
                continue;
            }

            // TODO: We do use a back camera for now
            if (facing != null && facing == CameraCharacteristics.LENS_FACING_BACK) {

                mSupportedPreviewSize = map.getOutputSizes(ImageFormat.JPEG);
                // Save Camera's feature
                mCameraCharacteristics = cameraManager.getCameraCharacteristics(cameraId);

                // 1. Get the largest supported preview size
                Size largestPreviewSize = Collections.max(
                        Arrays.asList(map.getOutputSizes(ImageFormat.JPEG)),
                        new CompareSizesByArea());

                LOG.d("1. Largest preview size : " + largestPreviewSize.getWidth() + " , " + largestPreviewSize.getHeight());

                // 2. Get the largest supported picture size

                // 3. Get Camera orientation to fix rotation problem
                // Find out if we need to swap dimension to get the preview size relative to sensor
                // coordinate.
                // https://developer.android.com/reference/android/hardware/Camera.CameraInfo.html
                /**
                 * The orientation of the camera image. The value is the angle that the camera image needs to be rotated clockwise so it shows correctly on the display in its natural orientation.
                 * It should be 0, 90, 180, or 270.
                 */
                mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
                LOG.d("3. Camera Lens orientation : " + mSensorOrientation);

                // 4. Get current display rotation
                WindowManager windowManager = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
                int displayRotation = windowManager.getDefaultDisplay().getRotation();
                LOG.d("4. Current device rotation : " + ORIENTATIONS.get(displayRotation));

                // 5. Check if dimensions should be swapped
                boolean swappedDimensions = false;
                switch (displayRotation) {
                    case Surface.ROTATION_0:
                    case Surface.ROTATION_180:
                        if (mSensorOrientation == 90 || mSensorOrientation == 270) {
                            swappedDimensions = true;
                        }
                        break;
                    case Surface.ROTATION_90:
                    case Surface.ROTATION_270:
                        if (mSensorOrientation == 0 || mSensorOrientation == 180) {
                            swappedDimensions = true;
                        }
                        break;
                }
                LOG.d("5. is Dimension swapped? : " + swappedDimensions);

                // 6. Get device resolution max size
                Point resolutionSize = new Point();
                windowManager.getDefaultDisplay().getSize(resolutionSize);
                int rotatedPreviewWidth = width;
                int rotatedPreviewHeight = height;
                int maxPreviewWidth = resolutionSize.x;
                int maxPreviewHeight = resolutionSize.y;

                if (swappedDimensions) {
                    rotatedPreviewWidth = height;
                    rotatedPreviewHeight = width;
                    maxPreviewWidth = resolutionSize.y;
                    maxPreviewHeight = resolutionSize.x;
                }
                LOG.d("6. Resolution Size : " + resolutionSize.x + " , " + resolutionSize.y);

                // 7. choose Optimal preview size!
                mPreviewSize = chooseOptimalSize(map.getOutputSizes(SurfaceTexture.class),
                        rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth, maxPreviewHeight,
                        largestPreviewSize);
                LOG.d("7. Optimal Preview size : " + mPreviewSize.getWidth() + " , " + mPreviewSize.getHeight());

                // 8. choose Optimal Picture size!
                mImageReader = ImageReader.newInstance(mPreviewSize.getWidth(), mPreviewSize.getHeight(),
                        ImageFormat.JPEG, /*maxImages*/2);
                mImageReader.setOnImageAvailableListener(
                        mOnImageAvailableListener, mBackgroundHandler);
                // Daniel (2016-11-04 12:18:33): Picture size should be equal or better than the largest preview size
                LOG.d("8. Optimal Picture size : " + mImageReader.getWidth() + " , " + mImageReader.getHeight());

                // 9. According to orientation, change SurfaceView size
                int orientation = getResources().getConfiguration().orientation;
                if (orientation == Configuration.ORIENTATION_PORTRAIT) {
                    LOG.d("9. Orientation PORTRAIT");
//            setAspectRatio(
//                    mPreviewSize.height, mPreviewSize.width);
                } else if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
                    LOG.d("9. Orientation LANDSCAPE");
//            setAspectRatio(
//                    mPreviewSize.width, mPreviewSize.height);
                }

                // Save camera id
                mCameraId = cameraId;
            }
        }
    }

    /**
     * Save offset of preview size to take picture with correct aspect ratio
     */
    RectF mConfigureTransformMargin = new RectF();

    /**
     * Initialize transform margin
     */
    private void initializeTransformMargin() {
        if (mConfigureTransformMargin == null) return;

        mConfigureTransformMargin.left = 0;
        mConfigureTransformMargin.right = 0;
        mConfigureTransformMargin.top = 0;
        mConfigureTransformMargin.bottom = 0;
    }

    /**
     * Configures the necessary {@link android.graphics.Matrix} transformation to `mTextureView`.
     * This method should be called after the camera preview size is determined in
     * setUpCameraOutputs and also the size of `mTextureView` is fixed.
     *
     * @param viewWidth  The width of `mTextureView`
     * @param viewHeight The height of `mTextureView`
     */
    private void configureTransform(SurfaceTexture surfaceTexture, int viewWidth, int viewHeight) {
        if (null == mPreviewSize)
            return;

        LOG.d("configureTransform () : " + viewWidth + " , " + viewHeight);

        // If your preview can change or rotate, take care of those events here.
        // Make sure to stop the preview before resizing or reformatting it.
        if (surfaceTexture == null) {
            // preview surface does not exist
            return;
        }

        // Set preview size and make any resize, rotate or
        // reformatting changes here
        // and start preview with new settings
        try {
            if (null == mPreviewSize ) {
                return;
            }
            WindowManager windowManager = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
            int rotation = windowManager.getDefaultDisplay().getRotation();
            Matrix matrix = new Matrix();
            RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);
            RectF bufferRect = new RectF(0, 0, mPreviewSize.getWidth(), mPreviewSize.getHeight());
            float centerX = viewRect.centerX();
            float centerY = viewRect.centerY();
            LOG.d("Surface rotation : " + ORIENTATIONS.get(rotation));
            LOG.d("Correct Orientation : " + isCorrectOrientation());
            LOG.d("Sensor orientation : " + mSensorOrientation);

            if (isCorrectOrientation()) {
                switch (rotation) {
                    // TODO: Test needed
                    case Surface.ROTATION_0: {
                        if (mConfigureTransformMargin == null) mConfigureTransformMargin = new RectF();
                        final float offset_x = (centerX - bufferRect.centerX());
                        final float offset_y = (centerY - bufferRect.centerY());

                        LOG.d("offset x  : " + offset_x);
                        LOG.d("offset y : " + offset_y);

                        initializeTransformMargin();

                        // if offset is positive then we don't need to add margin
                        if (offset_x < 0) {
                            mConfigureTransformMargin.left = offset_x;
                            mConfigureTransformMargin.right = offset_x;
                        }
                        if (offset_y < 0) {
                            mConfigureTransformMargin.top = offset_y;
                            mConfigureTransformMargin.bottom = offset_y;
                        }

                        bufferRect.offset(offset_x, offset_y);
                        matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);
                        break;
                    }
                    // Daniel (2016-11-05 18:18:41): Test Proved!
                    case Surface.ROTATION_90: {
                        // Daniel (2016-08-26 17:34:05): Reverse dst size
                        bufferRect = new RectF(0, 0, mPreviewSize.getHeight(), mPreviewSize.getWidth());

                        if (mConfigureTransformMargin == null) mConfigureTransformMargin = new RectF();
                        final float offset_x = (centerX - bufferRect.centerX());
                        final float offset_y = (centerY - bufferRect.centerY());

                        LOG.d("offset x  : " + offset_x);
                        LOG.d("offset y : " + offset_y);

                        initializeTransformMargin();

                        // if offset is positive then we don't need to add margin
                        // TODO: device rotation is 90, which means X, Y coordinates should be converted to each other.
                        if (centerX - bufferRect.centerY() < 0) {
                            mConfigureTransformMargin.left = centerX - bufferRect.centerY();
                            mConfigureTransformMargin.right = centerX - bufferRect.centerY();
                        }
                        if (centerY - bufferRect.centerX() < 0) {
                            mConfigureTransformMargin.top = centerY - bufferRect.centerX();
                            mConfigureTransformMargin.bottom = centerY - bufferRect.centerX();
                        }

                        bufferRect.offset(offset_x, offset_y);
                        matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);
                        matrix.postRotate(-90, centerX, centerY);
                        break;
                    }
                    // TODO: Test needed
                    case Surface.ROTATION_180: {
                        if (mConfigureTransformMargin == null) mConfigureTransformMargin = new RectF();
                        final float offset_x = (centerX - bufferRect.centerX());
                        final float offset_y = (centerY - bufferRect.centerY());

                        LOG.d("offset x  : " + offset_x);
                        LOG.d("offset y : " + offset_y);

                        initializeTransformMargin();

                        // if offset is positive then we don't need to add margin
                        if (offset_x < 0) {
                            mConfigureTransformMargin.left = offset_x;
                            mConfigureTransformMargin.right = offset_x;
                        }
                        if (offset_y < 0) {
                            mConfigureTransformMargin.top = offset_y;
                            mConfigureTransformMargin.bottom = offset_y;
                        }

                        bufferRect.offset(offset_x, offset_y);
                        matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);
                        matrix.postRotate(-180, centerX, centerY);
                        break;
                    }
                    // Daniel (2016-11-05 18:21:33): Test Proved!
                    // TODO: But it needs to be tested by Nexus 5 (sensor orientation is 270)
                    case Surface.ROTATION_270: {
                        // Daniel (2016-08-26 17:34:05): Reverse dst size
                        bufferRect = new RectF(0, 0, mPreviewSize.getHeight(), mPreviewSize.getWidth());

                        if (mConfigureTransformMargin == null) mConfigureTransformMargin = new RectF();
                        final float offset_x = (centerX - bufferRect.centerX());
                        final float offset_y = (centerY - bufferRect.centerY());

                        LOG.d("offset x  : " + offset_x);
                        LOG.d("offset y : " + offset_y);

                        initializeTransformMargin();

                        // if offset is positive then we don't need to add margin
                        // TODO: device rotation is 90, which means X, Y coordinates should be converted to each other.
                        if (centerX - bufferRect.centerY() < 0) {
                            mConfigureTransformMargin.left = centerX - bufferRect.centerY();
                            mConfigureTransformMargin.right = centerX - bufferRect.centerY();
                        }
                        if (centerY - bufferRect.centerX() < 0) {
                            mConfigureTransformMargin.top = centerY - bufferRect.centerX();
                            mConfigureTransformMargin.bottom = centerY - bufferRect.centerX();
                        }

                        bufferRect.offset(offset_x, offset_y);
                        matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);
                        matrix.postRotate(-270, centerX, centerY);
                        break;
                    }
                }
            } else {
                switch (rotation) {
                    // Daniel (2016-11-05 17:23:39): Test Proved!
                    // TODO: But it needs to be tested by Nexus 5 (sensor orientation is 270)
                    case Surface.ROTATION_0: {
                        // Daniel (2016-08-26 17:34:05): Reverse dst size
                        bufferRect = new RectF(0, 0, mPreviewSize.getHeight(), mPreviewSize.getWidth());

                        if (mConfigureTransformMargin == null) mConfigureTransformMargin = new RectF();
                        final float offset_x = (centerX - bufferRect.centerX());
                        final float offset_y = (centerY - bufferRect.centerY());

                        LOG.d("offset x  : " + offset_x);
                        LOG.d("offset y : " + offset_y);

                        initializeTransformMargin();

                        // if offset is positive then we don't need to add margin
                        if (offset_x < 0) {
                            mConfigureTransformMargin.left = offset_x;
                            mConfigureTransformMargin.right = offset_x;
                        }
                        if (offset_y < 0) {
                            mConfigureTransformMargin.top = offset_y;
                            mConfigureTransformMargin.bottom = offset_y;
                        }

                        bufferRect.offset(offset_x, offset_y);
                        matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);

                        // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)
                        // We have to take that into account and rotate JPEG properly.
                        // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.
                        // (In this case, add 90)
                        // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.
                        // (In this case, add -90)
                        matrix.postRotate(-mSensorOrientation + (mSensorOrientation == 90 ? 90 : -90), centerX, centerY);
                        break;
                    }
                    // TODO: Test needed
                    case Surface.ROTATION_90: {
                        bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());
                        matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);
//                    float scale = Math.max(
//                            (float) viewHeight / mPreviewSize.getHeight(),
//                            (float) viewWidth / mPreviewSize.getWidth());
//                    matrix.postScale(scale, scale, centerX, centerY);

                        matrix.postRotate(270, centerX, centerY);
                        break;
                    }
                    // TODO: Test needed
                    case Surface.ROTATION_180: {
                        // Daniel (2016-08-26 17:34:05): Reverse dst size
                        bufferRect = new RectF(0, 0, mPreviewSize.getHeight(), mPreviewSize.getWidth());

                        if (mConfigureTransformMargin == null) mConfigureTransformMargin = new RectF();
                        LOG.d("offset x  : " + (centerX - bufferRect.centerX()));
                        LOG.d("offset y : " + (centerY - bufferRect.centerY()));
                        mConfigureTransformMargin.left = 0;
                        mConfigureTransformMargin.top = 0;
                        mConfigureTransformMargin.right = centerX - bufferRect.centerX();
                        mConfigureTransformMargin.bottom = centerY - bufferRect.centerY();

                        matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);

                        matrix.postRotate(-mSensorOrientation, centerX, centerY);
                        break;
                    }
                    // TODO: Test needed
                    case Surface.ROTATION_270: {
                        bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());
                        matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);
//                    float scale = Math.max(
//                            (float) viewHeight / mPreviewSize.getHeight(),
//                            (float) viewWidth / mPreviewSize.getWidth());
//                    matrix.postScale(scale, scale, centerX, centerY);

                        matrix.postRotate(90, centerX, centerY);
                        break;
                    }
                }
            }
            setTransform(matrix);

            // 10. Set preview size
//            Camera.Parameters mParameters = mCamera.getParameters();
//            mParameters.setPreviewSize(mPreviewSize.width, mPreviewSize.height);
//            LOG.d("10. Set preview size : " + mPreviewSize.width + " , " + mPreviewSize.height);
//
//            // 11. Set Picture size & format
//            mParameters.setPictureSize(mPictureSize.width, mPictureSize.height);
////            mParameters.setPictureFormat(PixelFormat.JPEG);
//            LOG.d("11. Set Picture size : " + mPictureSize.width + " , " + mPictureSize.height);
//
//            mCamera.setParameters(mParameters);
//
//            mCamera.setPreviewTexture(surfaceTexture);
//            mCamera.startPreview();
        } catch (Exception e){
            e.printStackTrace();
        }
    }

    private void startPreview() throws CameraAccessException {
        SurfaceTexture texture = getSurfaceTexture();
        assert texture != null;

        // We configure the size of default buffer to be the size of camera preview we want.
        texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());

        // This is the output Surface we need to start preview.
        Surface surface = new Surface(texture);

        // We set up a CaptureRequest.Builder with the output Surface.
        mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        mPreviewRequestBuilder.addTarget(surface);

        try {
            // Here, we create a CameraCaptureSession for camera preview.
            mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),
                    new CameraCaptureSession.StateCallback(){

                        @Override
                        public void onConfigured(CameraCaptureSession session) {
                            try {
                                // The camera is already closed
                                if (mCameraDevice == null) return;

                                // When the session is ready, we start displaying the preview
                                mCameraCaptureSession = session;

                                // Auto focus should be continuous for camera preview.
//                                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,
//                                        CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

                                // AF currently believes it is in focus, but may restart scanning at any time. (No auto focus)
                                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,
                                        CameraMetadata.CONTROL_AF_MODE_AUTO);

                                // Finally, we start displaying the camera preview
                                mPreviewRequest = mPreviewRequestBuilder.build();
                                mCameraCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(), mCaptureCallback, mBackgroundHandler);
                            } catch (CameraAccessException e) {
                                e.printStackTrace();
                            }
                        }

                        @Override
                        public void onConfigureFailed(CameraCaptureSession session) {

                        }
                    }, null
            );
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    /**
     * Given {@code choices} of {@code Size}s supported by a camera, choose the smallest one that
     * is at least as large as the respective texture view size, and that is at most as large as the
     * respective max size, and whose aspect ratio matches with the specified value. If such size
     * doesn't exist, choose the largest one that is at most as large as the respective max size,
     * and whose aspect ratio matches with the specified value.
     *
     * @param choices           The list of sizes that the camera supports for the intended output
     *                          class
     * @param textureViewWidth  The width of the texture view relative to sensor coordinate
     * @param textureViewHeight The height of the texture view relative to sensor coordinate
     * @param maxWidth          The maximum width that can be chosen
     * @param maxHeight         The maximum height that can be chosen
     * @param aspectRatio       The aspect ratio
     * @return The optimal {@code Size}, or an arbitrary one if none were big enough
     */
    private static Size chooseOptimalSize(Size[] choices, int textureViewWidth,
                                          int textureViewHeight, int maxWidth, int maxHeight, Size aspectRatio) {

        // Collect the supported resolutions that are at least as big as the preview Surface
        List<Size> bigEnough = new ArrayList<>();
        // Collect the supported resolutions that are smaller than the preview Surface
        List<Size> notBigEnough = new ArrayList<>();
        int w = aspectRatio.getWidth();
        int h = aspectRatio.getHeight();
        for (Size option : choices) {
            if (option.getWidth() <= maxWidth && option.getHeight() <= maxHeight &&
                    option.getHeight() == option.getWidth() * h / w) {
                if (option.getWidth() >= textureViewWidth &&
                        option.getHeight() >= textureViewHeight) {
                    bigEnough.add(option);
                } else {
                    notBigEnough.add(option);
                }
            }
        }

        // Pick the smallest of those big enough. If there is no one big enough, pick the
        // largest of those not big enough.
        if (bigEnough.size() > 0) {
            return Collections.min(bigEnough, new CompareSizesByArea());
        } else if (notBigEnough.size() > 0) {
            return Collections.max(notBigEnough, new CompareSizesByArea());
        } else {
            return choices[0];
        }
    }

    @Override
    public void autoFocus() {
        super.autoFocus();
            // Start AF trigger
//            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
//                    CameraMetadata.CONTROL_AF_TRIGGER_START);
//
//            mCameraCaptureSession.capture(mPreviewRequestBuilder.build(), null, null);

            lockFocus();
    }

    /**
     * Lock the focus as the first step for a still image capture.
     */
    private synchronized void lockFocus() {
        try {
            // This is how to tell the camera to lock focus.
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                    CameraMetadata.CONTROL_AF_TRIGGER_START);

            // Tell #mCaptureCallback to wait for the lock.
            mState = STATE_WAITING_LOCK;
            mCameraCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(), mCaptureCallback, mBackgroundHandler);
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    /**
     * Unlock the focus. This method should be called when still image capture sequence is
     * finished.
     */
    private synchronized void unlockFocus() {
        try {
            // Reset the auto-focus trigger
            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                    CameraMetadata.CONTROL_AF_TRIGGER_CANCEL);
            mCameraCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,
                    mBackgroundHandler);
            // After this, the camera will go back to the normal state of preview.
            mState = STATE_PREVIEW;
            mCameraCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback,
                    mBackgroundHandler);
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    /**
     * Convert last changed orientation to correct degree
     * @param mLastOrientation
     * @return
     */
    private int getLastOrientation(int mLastOrientation) {
        if (!isOrientationEventAvailable) return 0;

        WindowManager windowManager = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
        int rotation = windowManager.getDefaultDisplay().getRotation();

        int orientation = getResources().getConfiguration().orientation;

        if (orientation == Configuration.ORIENTATION_PORTRAIT) {
            if (rotation == Surface.ROTATION_0) {
                if (mLastOrientation >= 45 && mLastOrientation <= 90 + 45)
                    return 90;
                else if (mLastOrientation >= 90 + 45 && mLastOrientation <= 90 * 2 + 45)
                    return 180;
                else if (mLastOrientation >= 90 * 2 + 45 && mLastOrientation <= 90 * 3 + 45)
                    return 270;
                return 0;
            } else {
                if (mLastOrientation >= 45 && mLastOrientation <= 90 + 45)
                    return 0;
                else if (mLastOrientation >= 90 + 45 && mLastOrientation <= 90 * 2 + 45)
                    return 90;
                else if (mLastOrientation >= 90 * 2 + 45 && mLastOrientation <= 90 * 3 + 45)
                    return 180;
                return 270;
            }
        } else {
            if (rotation == Surface.ROTATION_0) {
                if (mLastOrientation >= 45 && mLastOrientation <= 90 + 45)
                    return 90;
                else if (mLastOrientation >= 90 + 45 && mLastOrientation <= 90 * 2 + 45)
                    return 180;
                else if (mLastOrientation >= 90 * 2 + 45 && mLastOrientation <= 90 * 3 + 45)
                    return 270;
                return 0;
            } else {
                if (mLastOrientation >= 45 && mLastOrientation <= 90 + 45)
                    return 180;
                else if (mLastOrientation >= 90 + 45 && mLastOrientation <= 90 * 2 + 45)
                    return 270;
                else if (mLastOrientation >= 90 * 2 + 45 && mLastOrientation <= 90 * 3 + 45)
                    return 0;
                return 90;
            }
        }
    }

    @Override
    public void takePicture() {
        super.takePicture();

        captureStillPicture();
    }

    /**
     * Try to capture a still image from preview
     */
    private void captureStillPicture() {
        try {
            if (mCameraDevice != null) {
                // This is the CaptureRequest.Builder that we use to take a picture.
                final CaptureRequest.Builder captureBuilder =
                        mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
                captureBuilder.addTarget(mImageReader.getSurface());
                captureBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);

                // Daniel (2016-08-26 14:01:20): Current Device rotation
                WindowManager windowManager = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
                int displayRotation = windowManager.getDefaultDisplay().getRotation();
                LOG.d("Current device rotation : " + ORIENTATIONS.get(displayRotation));

                int result = (mSensorOrientation - ORIENTATIONS.get(displayRotation) + 360) % 360;
                captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, result);

                // Save converted orientation
                mLastConvertedOrientation = getLastOrientation(mLastOrientation);

                final CameraCaptureSession.CaptureCallback CaptureCallback
                        = new CameraCaptureSession.CaptureCallback() {

                    @Override
                    public void onCaptureCompleted(@NonNull CameraCaptureSession session,
                                                   @NonNull CaptureRequest request,
                                                   @NonNull TotalCaptureResult result) {

                        LOG.d("File path : " + mTakePictureFile.getAbsolutePath());
                        unlockFocus();
                    }
                };

                mCameraCaptureSession.stopRepeating();
                mCameraCaptureSession.capture(captureBuilder.build(), CaptureCallback, null);
            }
        } catch (CameraAccessException | IllegalStateException e){
            e.printStackTrace();
        }
    }

    @Override
    public void flashToggle() {
        super.flashToggle();

        LOG.d("flashTorch()");

        if (mCameraCharacteristics != null) {
            // Check if the flash is supported.
            Boolean available = mCameraCharacteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);
            if (available == null || !available) {
                throw new UnsupportedOperationException("Flash isn't supported!");
            }

            try {
                if (mPreviewRequestBuilder.get(CaptureRequest.FLASH_MODE) == CameraMetadata.FLASH_MODE_TORCH) {
                    mPreviewRequestBuilder.set(CaptureRequest.FLASH_MODE, CameraMetadata.FLASH_MODE_OFF);
                    mCameraCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(), null, null);
                } else {
                    mPreviewRequestBuilder.set(CaptureRequest.FLASH_MODE, CameraMetadata.FLASH_MODE_TORCH);
                    mCameraCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(), null, null);
                }
            } catch (CameraAccessException | NullPointerException e) {
                e.printStackTrace();
            }


        }
    }

    @Override
    public void setOnTakePictureListener(OnTakePictureListener onTakePictureListener) {
        this.onTakePictureListener = onTakePictureListener;
    }

    @Override
    public void setOrientationEventListener(boolean isEnabled) {
        super.setOrientationEventListener(isEnabled);

        isOrientationEventAvailable = isEnabled;

        if (isEnabled) {
            if (mOrientationEventListener == null) {
                mOrientationEventListener = new OrientationEventListener(getContext(),
                        SensorManager.SENSOR_DELAY_NORMAL) {
                    @Override
                    public void onOrientationChanged(int orientation) {
//                        LOG.d("Orientation : " + orientation);
                        if (orientation != -1)
                            mLastOrientation = orientation;
                    }
                };
            }

            if (mOrientationEventListener != null && mOrientationEventListener.canDetectOrientation())
                mOrientationEventListener.enable();
        } else {
            if (mOrientationEventListener != null) {
                mOrientationEventListener.disable();
                mOrientationEventListener = null;
            }

            mLastOrientation = 0;
        }
    }

    /**
     * You must call this method to release Camera
     */
    @Override
    public void releaseCamera() {
        LOG.d("Release Camera");

        if (mOrientationEventListener != null)
            mOrientationEventListener.disable();

        try {
            closeCamera();
            stopBackgroundThread();
        } catch (Exception e){
            e.printStackTrace();
        }

    }

    @Override
    public void finishCamera() {
        super.finishCamera();

        if (mOrientationEventListener != null) {
            mOrientationEventListener.disable();
            mOrientationEventListener = null;
        }

        try {
            mOnImageFinishedHandler = null;
            closeCamera();
            stopBackgroundThread();
        } catch (Exception e){
            e.printStackTrace();
        }
    }

    /**
     * Starts a background thread and its {@link Handler}.
     */
    private void startBackgroundThread() {
        mBackgroundThread = new HandlerThread("CameraBackground");
        mBackgroundThread.start();
        mBackgroundHandler = new Handler(mBackgroundThread.getLooper());
    }

    /**
     * Stops the background thread and its {@link Handler}.
     */
    private void stopBackgroundThread() {
        mBackgroundThread.quitSafely();
        try {
            mBackgroundThread.join();
            mBackgroundThread = null;
            mBackgroundHandler = null;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Close camera
     */
    private void closeCamera() {
        try {
            mCameraOpenCloseLock.acquire();
            if (null != mCameraCaptureSession) {
                mCameraCaptureSession.close();
                mCameraCaptureSession = null;
            }
            if (null != mCameraDevice) {
                mCameraDevice.close();
                mCameraDevice = null;
            }
            if (null != mImageReader) {
                mImageReader.close();
                mImageReader = null;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            if (mCameraOpenCloseLock != null)
                mCameraOpenCloseLock.release();
        }
    }

    /**
     * Saves a JPEG {@link Image} into the specified {@link File}.
     */
    private static class ImageSaver implements Runnable {
        private Logger LOG = Logger.getInstance();

        /**
         * The JPEG image
         */
        private final Image mImage;
        /**
         * The file we save the image into.
         */
        private final File mFile;

        private final Handler mHandler;

        private RectF mConfigureTransformMargin;

        private Integer mLastOrientation;

        public ImageSaver(Image image, File file, RectF configurationMargin, Integer lastOrientation, Handler handler) {
            mImage = image;
            mFile = file;
            mConfigureTransformMargin = configurationMargin;
            mLastOrientation = lastOrientation;
            mHandler = handler;
        }

        private Bitmap cropImage(Bitmap bitmap) {
            if (mConfigureTransformMargin == null || bitmap == null) return bitmap;
            if (mConfigureTransformMargin.left == 0 && mConfigureTransformMargin.top == 0 && mConfigureTransformMargin.right == 0 && mConfigureTransformMargin.bottom == 0) return bitmap;

            LOG.d("mConfigureMargin : " + mConfigureTransformMargin.toString());
            LOG.d("Bitmap size : " + bitmap.getWidth() + " , " + bitmap.getHeight());
            Bitmap rotatedBitmap = Bitmap.createBitmap(bitmap, (int) Math.abs(mConfigureTransformMargin.left), (int) Math.abs(mConfigureTransformMargin.top),
                    (int) (bitmap.getWidth() - Math.abs(mConfigureTransformMargin.right * 2)), (int) (bitmap.getHeight() - Math.abs(mConfigureTransformMargin.bottom * 2)));
            // TODO: Check if it is okay to recycle!!
            if (bitmap != null && bitmap != rotatedBitmap && !bitmap.isRecycled())
                bitmap.recycle();

            return rotatedBitmap;
        }

        private Bitmap rotateImage(Bitmap bitmap, int degrees) {
            if (bitmap == null) return bitmap;
            if (degrees % 360 == 0)
                return bitmap;

            Matrix matrix = new Matrix();
            matrix.postRotate(degrees);

            Bitmap rotatedBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
            // TODO: Check if it is okay to recycle!!
            if (bitmap != null && bitmap != rotatedBitmap && !bitmap.isRecycled())
                bitmap.recycle();

            return rotatedBitmap;
        }

        // Daniel (2016-04-29 18:15:01): Try to save image byte to file
        @Override
        public void run() {
            ByteBuffer buffer = mImage.getPlanes()[0].getBuffer();
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            FileOutputStream output = null;
            try {
                output = new FileOutputStream(mFile);

                if (mConfigureTransformMargin == null ||
                        (mConfigureTransformMargin.left == 0 && mConfigureTransformMargin.top == 0
                                && mConfigureTransformMargin.right == 0 && mConfigureTransformMargin.bottom == 0)) {
                    output.write(bytes);
                } else {
                    Bitmap bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
                    bitmap = cropImage(bitmap);

                    if (mLastOrientation % 360 != 0)
                        bitmap = rotateImage(bitmap, mLastOrientation);

                    bitmap.compress(Bitmap.CompressFormat.JPEG, 95, output);

                    // TODO: recycle Bitmap!!
                    if (bitmap != null) {
                        bitmap.recycle();
                        bitmap = null;
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                mImage.close();
                if (null != output) {
                    try {
                        output.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }

                // Daniel (2016-11-02 12:09:01): When FileOutputStream process has finished, report result to handler
                if (mHandler != null)
                    mHandler.sendEmptyMessage(DELIVER_FINISHED_TAKING_PICTURE);
            }
        }
    }

    private static File getOutputMediaFile() {
        File mediaStorageDir = new File(
                Environment
                        .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
                "CameraLibrary");
        if (!mediaStorageDir.exists()) {
            if (!mediaStorageDir.mkdirs()) {
                Log.e("CameraLogger", "failed to create directory");
                return null;
            }
        }
        // Create a media file name
        String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss")
                .format(new Date());
        File mediaFile;
        mediaFile = new File(mediaStorageDir.getPath() + File.separator
                + "CameraLibrary_"+ timeStamp +"_.jpg");

        return mediaFile;
    }

    /**
     * Compares two {@code Size}s based on their areas.
     */
    private static class CompareSizesByArea implements Comparator<Size> {

        @Override
        public int compare(Size lhs, Size rhs) {
            // We cast here to ensure the multiplications won't overflow
            return Long.signum((long) lhs.getWidth() * lhs.getHeight() -
                    (long) rhs.getWidth() * rhs.getHeight());
        }

    }
}
